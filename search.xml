<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[essential 第4章]]></title>
    <url>%2F2019%2F07%2F22%2Fessential-%E7%AC%AC4%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[1.实现class 所有的成员函数都需要在class中声明，定义可以待定 如果在class中定义，则成员函数将自动被视为inline函数，例如下面的size函数就是stack的一个inline函数。 在class外面定义函数，要声明inline，就需要使用inline关键字。 class stack{ public: bool push(const string&amp;); bool pop(string &amp;elem); bool peek(string &amp;elem); bool empty(); bool full(); int size(){ return _stack.size(); } private: vector&lt;string&gt; _stack;};inline bool stack ::empty() { //stack ::empty() 中的stack::告诉编译器，这个成员函数属于stack这个类 stack :: 类作用解析符 return _stack.empty();} 2.构造函数和析构函数 构造函数 的名字和类名一样，同时构造函数可以被重载 构造函数不需要指定返回类型，也不需要返回值 class triangular{ public: triangular(); triangular(int len); triangular(int len,int beg); private: int _length; int _beg; int _next;}; triangular::triangular() { _length=1; _beg=1; _next=0;} triangular t;triangular t2(10,3);triangular t3 =8;triangular t5(); //此时t5被定义为一个函数，t5之后带小括号，会被视作一个函数.triangular t5; //正确的定义方式 成员初始化列表 triangular::triangular(const triangular &amp;rhs):_length(rhs._length),_beg(rhs._beg),_next(rhs._next){ } &nbsp;通过初始化列表直接赋一个初值 class tri{ public: private: string _name; int _next,_length,_beg;}; tri::tri(int len,int bp):_name("triangular"){ _length=len&gt;0 ? len:1; _beg=bp &gt;0 ? bp:1; _next =_beg-1;} 析构函数 析构函数是用来释放在构造函数中或者对象生命周期中分配的资源 class matrix{public: matrix(int row,int col):_row(row),_col(col){ _pmt=new double[row*col]; } ~matrix(){ delete[] _pmt; } private: int _row,_col; double * _pmt;}; 3.mutable和const const class triangular{public: int length() const{ return _length; } int beg() const{ return _beg; } int elem(int pos) const; bool next(int &amp;val); void next_reset(){ _next=_beg-1; } private: int _length; int _beg; int _next; static vector&lt;int&gt; _elems}; int triangular ::elem(int pos) const { return _elems[pos-1]; const修饰符紧接于函数参数列表之后，凡是在class主题外定义的，如果是一个const成员函数，需要在定义声明中都指定const。const成员函数不能修改class中的成员变量，不然会报错，也就是不能改变private中的变量。 下面的程序会产生问题 下面的程序中，val程序会出现问题，val程序返回一个可变的指针指向_val，但是这个程序又是不能改变_val的值，等于将_val开放出去，允许程序在其他地方修改。 class val_class{ public: val_class(const bigclass &amp;v):_val(v){ } bigclass &amp;val()const { //存在问题 return _val; } private: bigclass _val;}; 解决办法： class val_class{ public: val_class(const bigclass &amp;v):_val(v){ } const bigclass &amp;val()const { return _val; } bigclass &amp;val(){ return _val; } private: bigclass _val;};void example(const bigclass *pbc,bigclass &amp;rbc){ pbc-&gt;val(); //调用const版本的函数 此处的pbc的值是不可变的 rbc.val(); //调用传统的函数} mutable 通过将成员变量设置为mutable，可以才调用是，改变其值。 如下程序，在sum函数中，传入的tri为const型，无法改变其大小，而函数通调用了next_reset()，改变了_next的值，所以会出错，将_next声明为mutable后，就不会改变class object的常量性 所以next()和next_reset()既可以修改_next的值，还可以被声明为const成员函数，这样sum()也不会报错 class triangular{public: bool next(int &amp;val) const; void next_reset() const{ _next=_beg-1; }private: int _length; int _beg; mutable int _next;}; int sum(const triangular &amp;tri){ if(!tri.length()) return 0; int val ,sum=0; tri.next_reset(); while (tri.next(val)) sum+=val; return sum;} 4.this指针 设计一个copy函数，使得一个class object作为另一个对象的初始值 ，copy必须返回被复制的对象，tr1不仅是复制的目标，还是接受复制的结果 triangular tr1(8)triangular tr2(8,9)tr1.copy(tr2) triangular &amp;triangular ::copy(const triangular &amp;rhs){ _length=rhs._length; _beg=rhs._beg; _next=rhs._beg-1; return *this} this指针在成员函数中用来指向其调用者，即this指向tr1，编译器自动将this指针加到每一个成员函数中，copy被转换成一下的形式： triangular &amp;triangular ::copy(triangular *this,const triangular &amp;rhs){ this-&gt;_length=rhs._length; this-&gt;_beg=rhs._beg; this-&gt;_next=rhs._beg-1; } 在调用copy的时候，tr1.copy(tr2)，转换为copy（&amp;tr1，tr2） triangular &amp;triangular ::copy(triangular *this,const triangular &amp;rhs){ if(this !=&amp;rhs){ this-&gt;_length=rhs._length; this-&gt;_beg=rhs._beg; this-&gt;_next=rhs._beg-1; }} 5.静态类成员 静态成员变量用来表示唯一的，可共享的成员，可以在同一类的所有对象中被访问 class triangular{public: private: static vector&lt;int&gt; _elems;}; 对于类而言，静态成员变量只有唯一的一份实体，因此必须给出他的清楚的定义，同时需要指定他的类作用域运算符 vector&lt;int&gt; triangular::_elems 静态成员函数 一般情况下，成员函数必须通过其类的某个对象来实现调用，这个对象会绑定至这个成员函数的this指针，通过存储于每个对象的this指针，成员函数才能访问每个对象中的非静态成员变量。 静态成员函数可以在没有指定对象的基础上被调用 注意：静态成员函数只有在不访问任何的非静态成员变量的时候，也就是静态成员函数中的成员变量需要都是静态的，这个函数才能被声明为静态成员函数。 class triangular{public: static bool is_elem(int); static void gen_elements(int _length); static void gen_elem_to_value(int value); static void display(int length,int beg,ostream &amp;os=cout);private: static vector&lt;int&gt; _elems; static const int _max_elems=1024;}; void triangular ::gen_elem_to_value(int value) { int ix=_elems.size(); if(!ix){ _elems.push_back(1); ix=1; } while(_elems[ix-1]&lt;value &amp;&amp;ix&lt;_max_elems){ ++ix; _elems.push_back(ix*(ix+1)/2); } if(ix=_max_elems){ cerr&lt;&lt; value&lt;&lt; "-- exceeds max size of " &lt;&lt; _max_elems&lt;&lt;endl; }} 在类的主体外部进行成员函数的定义，不需要加上static 调用成员函数的时候，不需要依靠任何对象 #include &lt;iostream&gt;#include "triangular"using namespace std;int main(){ char ch; bool more=true; while (more){ cout &lt;&lt; "enter value:"; int val; cin &gt;&gt; val; bool is_elem=triangular::is_elem(val); //可以直接调用静态成员函数 }} 6.类的运算符重载 triangular trian(1,8)triangular::iterator it =trian.begin(),end_it=trian.end();while(it !=end_it){ cout &lt;&lt; *it&lt;&lt;" "; ++it;} 需要为类重载==、！=、++、*等运算符。使用operator关键字重载函数 class tri{public: tri(int index):_index(index-1); bool operator==(const tri&amp;)const; bool operator!=(const tri&amp;)const; int operator*()const; tri&amp; operator++(); tri&amp; operator++(int); private: int _index;}; inline bool tri::operator==(const tri &amp;rhs) const { return _index=rhs._index;} inline bool tri::operator!=(const tri &amp;rhs) const { //相反的运算符，可以相互实现，此处用了之前重载的==运算符，直接定义！= return !(*this==rhs);} inline int tri::operator*() const { return tri::_elems[_index]} inline tri&amp; tri::operator++() { //前置的递增 ++it ++_index; return *this;} inline tri&amp; tri::operator++(int) { //后置的 it++ 加入int是为了重载 通过参数列表的不同重载 tri temp=*this; ++_index; return temp;} 嵌套类型 typedef existing_type new_name 可以将任何一个内置类型，复合类型或class，简化为其他形式 7.friend 10 重载iostream运算符 ostream&amp; operator&lt;&lt;(ostream &amp;os,const triangular &amp;rhs){ os &lt;&lt; "("&lt;&lt;rhs.beg&lt;&lt;"," &lt;&lt;rhs.length &lt;&lt;")"; return os;} 不能把ostream设置为成员函数，作为一个成员函数，其左操作数必须是同一个类的对象，如果把output设置为成员函数，就会出现如下的形式： tri &lt;&lt;cout &lt;&lt; '\n'; 这种不符合常用的操作习惯 传入函数的ostream对象有返回，这样可以串接多个output运算符 istream&amp; operator&gt;&gt;(istream &amp;is,triangular &amp;rhs){ char ch1,ch2; int bp,len; is &gt;&gt; ch1&gt;&gt;bp &gt;&gt;ch2&gt;&gt;len; rhs.beg(bp); rhs.length(len); rhs.next(); return is;} &nbsp;]]></content>
      <categories>
        <category>essential c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[essential第三章]]></title>
    <url>%2F2019%2F07%2F14%2F%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[1.指针的运算 可以对指针使用下标运算符 下标运算符就相当于在起始地址的基础上加上索引值，产生某个元素的地址 #include&lt;iostream&gt;using namespace std;int main(){ int a[]={1,2,3,4,5}; int *p=a; cout &lt;&lt; p[1];//或者cout &lt;&lt; *(p+1); cout&lt;&lt; *p[1]是错误的} 上面程序的输出为2， 所以 p[1] = *(p+1) 对于书中的对vector和array的泛型算法： template &lt;typename elemtype&gt;elemtype* find(const elemtype *array,int size,const elemtype &amp;value){ // array就是数组的首地址 if(!array || size&lt;1){ return 0; } for(int i=0;i&lt;size;i++){ if(array[i]==value) return &amp;array[i]; //可以看出array[i]是一个具体的值。而不是对象，就相当于数组一样 } return 0;} 除了使用指针的下标计算外，还可以： template &lt;typename elemtype&gt;elemtype* find(const elemtype *array,int size,const elemtype &amp;value){ if(!array || size&lt;1){ return 0; } for(int i=0;i&lt;size;i++,++array){ //由此 for语句不仅仅是每个部分一句，可以多句 if(*array==value) //由地址提领到他的值 return array; //返回当前地址 } return 0;} 2.iterator 需要实现的功能 for(iter=vec.begin();iter !=vec.end();++iter){ cout &lt;&lt; *iter &lt;&lt; endl;} vector&lt;int&gt; vec;vector&lt;int&gt; ::iterator iter=vec.begin() 可以通过iter调用vector的函数 iter-&gt;size() 3.容器公用的操作 4.使用顺序性容器 定义容器的方式 // 产生空的容器vector&lt;int&gt; vec;list&lt;string&gt; ilist; //产生特定大小的容器，每个元素为默认值，int double默认值为0list&lt;int&gt; ilist(1024);vector&lt;string&gt; ivec(32); //产生特定大小的容器，并为每个元素赋初值vector&lt;int&gt; ivec(10,-1)list&lt;string&gt; slist(16,"abcdefg") //通过对iterator产生容器int ia[8]={1,2,3,4,5,6,7,8}vector&lt;int&gt; fib(ia,ia+8) //通过一个容器，产生另外一个容器list&lt;string&gt; slist;list&lt;string&gt; slist2(slist) 容器的插入和删除的操作 push_back()//末尾插入pop_back()//末尾删除 5.使用泛型算法 6.设计泛型算法 设计一个程序，给与一个vector，现在返回一个vector，内含原vector中所有小于10的元素 vector&lt;int&gt;less_than_10(const vector&lt;int&gt; &amp;vec){ vector&lt;int&gt; nvec; for (int i = 0; i &lt; vec.size(); ++i) { if(vec[i]&lt;10) nvec.push_back(vec[i]); } return nvec;} 现在要去改进程序，可以指定边界数，同时可以指定大于、小于、等于 vector&lt;int&gt; filter(const vector&lt;int&gt; &amp;vec,int value,bool (*pred)(int,int)){ vector&lt;int&gt; nvec; for(int i=0;i&lt;vec.size();i++){ if(pred(vec[i],value)) nvec.push_back(vec[i]); } return nvec;} bool less_than(int a,int b){ return a&lt;b ? true:false;} bool more_than(int a,int b){return a&gt;b ? true:false;} 这里使用函数指针，通过函数指针可以达到指定大于小于的作用，记住，函数名和数组名一样，本质上就是指针，是一个地址。 实际的完整程序 #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt;less_than_10(const vector&lt;int&gt; &amp;vec){ vector&lt;int&gt; nvec; for (int i = 0; i &lt; vec.size(); ++i) { if(vec[i]&lt;10) nvec.push_back(vec[i]); } return nvec;} //使用函数指针 vector&lt;int&gt; filter(const vector&lt;int&gt; &amp;vec,int value,bool (*pred)(int,int)){ vector&lt;int&gt; nvec; for(int i=0;i&lt;vec.size();i++){ if(pred(vec[i],value)) nvec.push_back(vec[i]); } return nvec;} bool less_than(int a,int b){ return a&lt;b ? true:false;} bool more_than(int a,int b){return a&gt;b ? true:false;} //vector&lt;int&gt; avec=filter(big_vec,value,less_than)int main(){ int a[6]; for(int i=0;i&lt;6;i++){ int b; cin &gt;&gt; b; a[i]=b; } vector&lt;int&gt;vec(a,a+6); vector&lt;int&gt; svec=filter(vec,5,less_than); for(int i=0;i&lt;svec.size();i++){ cout &lt;&lt; svec[i] &lt;&lt; endl; }} function object //头文件#include&lt;functional&gt; 可以实现： sort(vec.begin(),vec.end()，greater&lt;int&gt;) 通过greater，可以使得排列之后的容器是从大到小 常用的有： 算术运算符：plus&lt;type&gt;、minus&lt;type&gt;、negate&lt;type&gt;、multiplies&lt;type&gt;、divides&lt;type&gt;关系运算符：less&lt;type&gt;、less_equal&lt;type&gt;、greater&lt;type&gt;、greater_equal&lt;type&gt;、 equal&lt;type&gt;、not_equal_to&lt;type&gt;逻辑运算符：logical_and&lt;type&gt;、logical_or&lt;type&gt;、logical_not&lt;type&gt; function object adapter 例如上面的less&lt;type&gt;，是希望外界传入两个值，如果符合要求，就返回true，而我们设置的filter函数事希望传入的一个值一直和设定的值比较，所以需要使用adapter，将less&lt;type&gt;转化为一元运算符。 使用bind1st将值绑定到第一操作数，bind2nd将值绑定到第二操作数。 vector&lt;int&gt; filter(const vector&lt;int&gt; &amp;vec,int value,less&lt;int&gt; &amp;lt){ vector&lt;int&gt; nvec; vector&lt;int&gt; ::iterator iter=nvec.begin(); while((iter=find_if(iter,nvec.end(),bind2nd(lt,value)))!=nvec.end()){ nvec.push_back(*iter); iter++; } return nvec;}]]></content>
      <categories>
        <category>essential c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建]]></title>
    <url>%2F2019%2F07%2F13%2Fhexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1.hexo首页不显示全文 希望达到的效果 首页显示文章列表，列表里的每一篇文章只显示预览，不显示全文。 进入hexo博客项目的themes/next目录 用文本编辑器打开_config.yml文件 搜索"auto_excerpt",找到如下部分： # Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 把enable改为对应的false改为true，然后hexo d -g，再进主页，问题就解决了！ 2.添加Live2D小宠物 安装Live2D插件 npm install --save hexo-helper-live2d npm install --save live2d-widget-model-&lt;你喜欢的模型名字&gt; &nbsp;下面是常用的模型 可以在此预览 live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 修改配置文件 在博客根目录的_config.yml配置文件中添加下面的内容 #Live2D动画live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-shizuku display: position: right width: 150 height: 300 mobile: show: true 主要参数说明 enable //是否使用 model: use: live2d-widget-model-shizuku //要使用的模型名称 display: position: right //显示的位置 width: 150&nbsp;&nbsp; &nbsp;//宽度 height: 150&nbsp;&nbsp; &nbsp;//高度 mobile: show: true&nbsp;&nbsp; &nbsp;//移动端是否显示 &nbsp; 3.添加分类以及标签 nexT主题的文章分类和标签设置，其他主题也应该是类似的。添加成功后会在侧边栏或导航栏生成“分类”和“标签”这两个选项 &nbsp; 见如下博客以及这篇]]></content>
      <categories>
        <category>环境搭建</category>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[conda常用命令整理]]></title>
    <url>%2F2019%2F07%2F13%2Fconda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[安装anaconda发行版中所有的包 conda install anaconda 查看当前虚拟环境cuda cudnn版本 &nbsp;conda list 并查看 cat /usr/local/cuda-9.0/version.txtcat /usr/local/cuda-9.0/include/cudnn.h | grep CUDNN_MAJOR -A 2 更换清华源 不同的安装包存在的位置可能不一样，例如cuda不同版本的安装包分别在free和main里面 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ &nbsp; 安装指定版本的tensorflow conda install --channel https://conda.anaconda.org/anaconda tensorflow-gpu=1.5.0 或者 pip3 install tensorflow-gpu==1.5 -i https://pypi.tuna.tsinghua.edu.cn/simple 移除虚拟环境 conda env remove -n python35 安装opencv conda install --channel https://conda.anaconda.org/menpo opencv3 pip使用国内源 加上 -i https://pypi.tuna.tsinghua.edu.cn/simple 例如安装 例如： pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider 这样就会从清华这边的镜像去安装pyspider库。 安装8.0版本的cuda&nbsp; 安装固定版本的cuda cudnn conda install cudatoolkit=8.0 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/linux-64/ conda install cudnn=7.0.5 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/ &nbsp; &nbsp;9.0版本以上的cuda&nbsp; &nbsp;可以查看清华源中有没有cuda的对应版本 conda install cudatoolkit=9.0 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/ conda install cudnn=7.1.2 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/ pytorch torchvision指定版本 conda install pytorch=0.3.0 torchvision=0.2.0 -c soumith &nbsp;]]></content>
      <categories>
        <category>环境搭建</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>环境搭建 深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[essential第二章]]></title>
    <url>%2F2019%2F07%2F13%2Fessential%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[1.编写函数 返回类型 函数名 参数列表 必须先声明，定义可以延后 返回值 必须在每个可能的退出点上将值返回，函数体的最后一句不是return，则这一句就是函数的隐式退出点 2.调用函数 传值 传值时，传入的值和原来的值得唯一的联系，就是值相同，相当于复制了一份，在我们调用函数的时候，会在内存中建立一个特殊区域，程序堆栈，为每个函数的参数提供存储空间，一旦函数完成，内存就会释放。这些对象为局部对象。 传址 传址的方式传入函数的是对象的地址，而不是复制的一份，采用引用的方式传入。 void display(const vector&lt;int&gt; &amp;vec){ for(int i=0;i&lt;vec.size();i++){ cout &lt;&lt; vec[i] &lt;&lt; " "; cout &lt;&lt; endl; }} 作用域和范围 函数内定义的对象，只存在于函数执行的期间，如果把这些局部对象的地址返回，会出错。 int* display(const vector&lt;int&gt; &amp;vec){ int a; a=3; return &amp;a;} 3.默认参数值 void display(const vector&lt;int&gt; &amp;vec,ostream &amp;os=cout){ for(int i=0;i&lt;vec.size();i++){ os &lt;&lt; vec[i] &lt;&lt; endl; }} 定义一个ostream的对象，将其的初值赋值为cout，这样默认的是打印在屏幕上，也可以选择输出到文件中。 4.局部静态对象 const vector&lt;int&gt; *seq(int size){ static vector&lt;int&gt; elems; return &amp;elems;} 此时函数可以返回静态局部变量的地址，因为在函数执行结束的时候，elem并不会从内存中消失，依然存在，其存在的范围是当前的文件中。 5.inline函数 inline函数的作用，就是声明当前的函数，要求编译器在每个函数的调用点上，将函数展开。 6.重载函数 不能根据返回值的类型来重载函数，而是参数列表中，参数类型以及参数数量的不同 7.模板函数 template &lt;typename elemtype&gt;void display_message(const string &amp;msg,const vector&lt;elemtype&gt; &amp;vec){ cout &lt;&lt; msg; for(int i=0;i&lt;vec.size();i++){ elemtype t=vec[i]; cout &lt;&lt; t &lt;&lt; ' '; }} 其实就是定义一个类型，函数不指定类型的输入，elemtype是一个暂时存放类型的占位符。 8.函数指针 首先要注意 int *f(int i, int j); int (*p)(int i, int j); 第一个是返回指针的函数，第二个是指向函数的函数指针， 函数名和数组类似，也是代表函数所存放的地址，函数名就代表了函数的地址。 函数指针的定义 将函数名换成指针，同时制定参数列表。 double add(double x, double y){&nbsp;&nbsp; &nbsp;return x + y;} //函数指针double (*pf)（double,double）=add; &nbsp;//这里(*pf)的括号不能省，不然就不是函数指针了。 函数指针的数组 double add(double x, double y){ return x + y;} double add2(double x, double y){ return x - y;}double (*pf[2])(double,double) = { add, add2 }; pf是有2个函数指针的数组 应用 对于第一种， #include&lt;iostream&gt;using namespace std;double add(double x, double y){ return x + y;} double calculate(double x1, double y1, double(*f)(double, double)) //函数调用里面传递 函数指针数组 的方法{ cout &lt;&lt; "add:" &lt;&lt; (*f)(x1, y1) &lt;&lt; endl; return 1;} int main(){ double (*pf)(double,double)=add; //这里(*pf)的括号不能省，不然就不是函数指针了。 int x = 2,y = 1; calculate(x, y, pf); //直接calculate(x, y, add);也是可以的 } 第二种： #include "iostream"&nbsp;using namespace std;&nbsp;double add(double, double);double add2(double x, double y);&nbsp;double calculate(double x1, double y1, double(*f[])(double, double)) &nbsp;//函数调用里面传递 函数指针数组 的方法 {&nbsp;&nbsp; &nbsp;cout &lt;&lt; "add:" &lt;&lt; (*f[0])(x1, y1) &lt;&lt; endl;&nbsp;&nbsp; &nbsp;cout &lt;&lt; "add2:" &lt;&lt; (*f[1])(x1, y1) &lt;&lt; endl;&nbsp;&nbsp; &nbsp;return &nbsp;1;}&nbsp;int main(){&nbsp;&nbsp; &nbsp;int x, y;&nbsp;&nbsp; &nbsp;double (*pf[2])(double,double) = { add, add2 };&nbsp;//&nbsp;&nbsp; &nbsp;x = 2; y = 1;&nbsp;&nbsp; &nbsp;calculate(x, y, pf); //注意此处的pf，他是函数的名字，就是指针，而这个指针指向的还是指针，即add这个函数名（函数名也是指针），所以在calculate函数的定义中，要用(*f[])或者(**f)&nbsp;&nbsp;&nbsp; &nbsp;system("pause()");&nbsp;&nbsp; &nbsp;return 0;}&nbsp;&nbsp;&nbsp;double add(double x, double y){&nbsp;&nbsp; &nbsp;return x + y;}&nbsp;double add2(double x, double y){&nbsp;&nbsp; &nbsp;return x - y;} 然后建立函数数组并赋值 &nbsp;double (*pf[2])(double,double) = { add, add2 };&nbsp; 接着传递给上面定义的calculate函数。调用方式为：calculate(x, y, pf); calculate函数的接收方式应为：double calculate(double x1, double y1, double(**f)(double, double)) //传递的pf是一个数组的数组名且本身也是一个指针，即为二重指针 &nbsp;&nbsp;&nbsp;&nbsp;或者double calculate(double x1, double y1, double(*f[])(double, double)) 9.头文件 将函数的声明放在头文件中，方便多个程序调用&nbsp;]]></content>
      <categories>
        <category>essential c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[essential第一章整理]]></title>
    <url>%2F2019%2F07%2F13%2Fessential%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[1.array和vector 定义array，必须指定array的元素类型，名称，指定尺度的大小，并且这个大小必须是常量表达式 vector本身的大小就是可变的，因此不一定要指定大小的时候为常量表达式 //arrayconst int seq_size=18; //定义一个常量表达式int pell_seq[seq_size]; //vectorint a=10; //变量vector&lt;int&gt; b(a); 同时还可以让计算机自行计算array的大小 int elem_seq[]={1,2,3,4,5,6,7,8,9}; 2.指针 指针调用成员函数： vector&lt;int&gt; fib;vector&lt;int&gt; *pv=0;pv=&amp;fib; //成员函数的调用方式 fib.empty()pv-&gt;empty() 3.文件的读写 文件的输出 #include&lt;fstream&gt;ofstream outfile("1.txt"); //定义了一个ofstream类的outfile的对象//没有ofstream outfile ="1.txt"的写法int a=3;outfile &lt;&lt; a; //相当于把a的值送给outfile 当没有1.txt文件的时候，会创建这个文件，并输出 同时outfile的类型为bool型，可以判断文件是否成功打开 if(!outfile) //如果文件没有成功打开，则为false 文件的输入 ifstream infile("2.txt")int a;infile &gt;&gt; a; //将infile的值送给awhile(infile &gt;&gt;a) 同时 cin&gt;&gt;的终止符为空格、tab、回车 &nbsp;]]></content>
      <categories>
        <category>essential c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[try]]></title>
    <url>%2F2019%2F07%2F13%2Ftry%2F</url>
    <content type="text"><![CDATA[first time]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>表格</tag>
        <tag>表单验证</tag>
      </tags>
  </entry>
</search>
