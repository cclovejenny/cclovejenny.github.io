<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[conda常用命令整理]]></title>
    <url>%2F2019%2F07%2F13%2Fconda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[安装anaconda发行版中所有的包 conda install anaconda 查看当前虚拟环境cuda cudnn版本 &nbsp;conda list 并查看 cat /usr/local/cuda-9.0/version.txtcat /usr/local/cuda-9.0/include/cudnn.h | grep CUDNN_MAJOR -A 2 更换清华源 不同的安装包存在的位置可能不一样，例如cuda不同版本的安装包分别在free和main里面 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ &nbsp; 安装指定版本的tensorflow conda install --channel https://conda.anaconda.org/anaconda tensorflow-gpu=1.5.0 或者 pip3 install tensorflow-gpu==1.5 -i https://pypi.tuna.tsinghua.edu.cn/simple 移除虚拟环境 conda env remove -n python35 安装opencv conda install --channel https://conda.anaconda.org/menpo opencv3 pip使用国内源 加上 -i https://pypi.tuna.tsinghua.edu.cn/simple 例如安装 例如： pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider 这样就会从清华这边的镜像去安装pyspider库。 安装8.0版本的cuda&nbsp; 安装固定版本的cuda cudnn conda install cudatoolkit=8.0 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/linux-64/ conda install cudnn=7.0.5 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/ &nbsp; &nbsp;9.0版本以上的cuda&nbsp; &nbsp;可以查看清华源中有没有cuda的对应版本 conda install cudatoolkit=9.0 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/ conda install cudnn=7.1.2 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/ pytorch torchvision指定版本 conda install pytorch=0.3.0 torchvision=0.2.0 -c soumith &nbsp;]]></content>
      <categories>
        <category>环境搭建</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>环境搭建 深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[essential第二章]]></title>
    <url>%2F2019%2F07%2F13%2Fessential%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[1.编写函数 返回类型 函数名 参数列表 必须先声明，定义可以延后 返回值 必须在每个可能的退出点上将值返回，函数体的最后一句不是return，则这一句就是函数的隐式退出点 2.调用函数 传值 传值时，传入的值和原来的值得唯一的联系，就是值相同，相当于复制了一份，在我们调用函数的时候，会在内存中建立一个特殊区域，程序堆栈，为每个函数的参数提供存储空间，一旦函数完成，内存就会释放。这些对象为局部对象。 传址 传址的方式传入函数的是对象的地址，而不是复制的一份，采用引用的方式传入。 void display(const vector&lt;int&gt; &amp;vec){ for(int i=0;i&lt;vec.size();i++){ cout &lt;&lt; vec[i] &lt;&lt; " "; cout &lt;&lt; endl; }} 作用域和范围 函数内定义的对象，只存在于函数执行的期间，如果把这些局部对象的地址返回，会出错。 int* display(const vector&lt;int&gt; &amp;vec){ int a; a=3; return &amp;a;} 3.默认参数值 void display(const vector&lt;int&gt; &amp;vec,ostream &amp;os=cout){ for(int i=0;i&lt;vec.size();i++){ os &lt;&lt; vec[i] &lt;&lt; endl; }} 定义一个ostream的对象，将其的初值赋值为cout，这样默认的是打印在屏幕上，也可以选择输出到文件中。 4.局部静态对象 const vector&lt;int&gt; *seq(int size){ static vector&lt;int&gt; elems; return &amp;elems;} 此时函数可以返回静态局部变量的地址，因为在函数执行结束的时候，elem并不会从内存中消失，依然存在，其存在的范围是当前的文件中。 5.inline函数 inline函数的作用，就是声明当前的函数，要求编译器在每个函数的调用点上，将函数展开。 6.重载函数 不能根据返回值的类型来重载函数，而是参数列表中，参数类型以及参数数量的不同 7.模板函数 template &lt;typename elemtype&gt;void display_message(const string &amp;msg,const vector&lt;elemtype&gt; &amp;vec){ cout &lt;&lt; msg; for(int i=0;i&lt;vec.size();i++){ elemtype t=vec[i]; cout &lt;&lt; t &lt;&lt; ' '; }} 其实就是定义一个类型，函数不指定类型的输入，elemtype是一个暂时存放类型的占位符。 8.函数指针 首先要注意 int *f(int i, int j); int (*p)(int i, int j); 第一个是返回指针的函数，第二个是指向函数的函数指针， 函数名和数组类似，也是代表函数所存放的地址，函数名就代表了函数的地址。 函数指针的定义 将函数名换成指针，同时制定参数列表。 double add(double x, double y){&nbsp;&nbsp; &nbsp;return x + y;} //函数指针double (*pf)（double,double）=add; &nbsp;//这里(*pf)的括号不能省，不然就不是函数指针了。 函数指针的数组 double add(double x, double y){ return x + y;} double add2(double x, double y){ return x - y;}double (*pf[2])(double,double) = { add, add2 }; pf是有2个函数指针的数组 应用 对于第一种， #include&lt;iostream&gt;using namespace std;double add(double x, double y){ return x + y;} double calculate(double x1, double y1, double(*f)(double, double)) //函数调用里面传递 函数指针数组 的方法{ cout &lt;&lt; "add:" &lt;&lt; (*f)(x1, y1) &lt;&lt; endl; return 1;} int main(){ double (*pf)(double,double)=add; //这里(*pf)的括号不能省，不然就不是函数指针了。 int x = 2,y = 1; calculate(x, y, pf); //直接calculate(x, y, add);也是可以的 } 第二种： #include "iostream"&nbsp;using namespace std;&nbsp;double add(double, double);double add2(double x, double y);&nbsp;double calculate(double x1, double y1, double(*f[])(double, double)) &nbsp;//函数调用里面传递 函数指针数组 的方法 {&nbsp;&nbsp; &nbsp;cout &lt;&lt; "add:" &lt;&lt; (*f[0])(x1, y1) &lt;&lt; endl;&nbsp;&nbsp; &nbsp;cout &lt;&lt; "add2:" &lt;&lt; (*f[1])(x1, y1) &lt;&lt; endl;&nbsp;&nbsp; &nbsp;return &nbsp;1;}&nbsp;int main(){&nbsp;&nbsp; &nbsp;int x, y;&nbsp;&nbsp; &nbsp;double (*pf[2])(double,double) = { add, add2 };&nbsp;//&nbsp;&nbsp; &nbsp;x = 2; y = 1;&nbsp;&nbsp; &nbsp;calculate(x, y, pf); //注意此处的pf，他是函数的名字，就是指针，而这个指针指向的还是指针，即add这个函数名（函数名也是指针），所以在calculate函数的定义中，要用(*f[])或者(**f)&nbsp;&nbsp;&nbsp; &nbsp;system("pause()");&nbsp;&nbsp; &nbsp;return 0;}&nbsp;&nbsp;&nbsp;double add(double x, double y){&nbsp;&nbsp; &nbsp;return x + y;}&nbsp;double add2(double x, double y){&nbsp;&nbsp; &nbsp;return x - y;} 然后建立函数数组并赋值 &nbsp;double (*pf[2])(double,double) = { add, add2 };&nbsp; 接着传递给上面定义的calculate函数。调用方式为：calculate(x, y, pf); calculate函数的接收方式应为：double calculate(double x1, double y1, double(**f)(double, double)) //传递的pf是一个数组的数组名且本身也是一个指针，即为二重指针 &nbsp;&nbsp;&nbsp;&nbsp;或者double calculate(double x1, double y1, double(*f[])(double, double)) 9.头文件 将函数的声明放在头文件中，方便多个程序调用&nbsp;]]></content>
      <categories>
        <category>essential c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[essential第一章整理]]></title>
    <url>%2F2019%2F07%2F13%2Fessential%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[1.array和vector 定义array，必须指定array的元素类型，名称，指定尺度的大小，并且这个大小必须是常量表达式 vector本身的大小就是可变的，因此不一定要指定大小的时候为常量表达式 //arrayconst int seq_size=18; //定义一个常量表达式int pell_seq[seq_size]; //vectorint a=10; //变量vector&lt;int&gt; b(a); 同时还可以让计算机自行计算array的大小 int elem_seq[]={1,2,3,4,5,6,7,8,9}; 2.指针 指针调用成员函数： vector&lt;int&gt; fib;vector&lt;int&gt; *pv=0;pv=&amp;fib; //成员函数的调用方式 fib.empty()pv-&gt;empty() 3.文件的读写 文件的输出 #include&lt;fstream&gt;ofstream outfile("1.txt"); //定义了一个ofstream类的outfile的对象//没有ofstream outfile ="1.txt"的写法int a=3;outfile &lt;&lt; a; //相当于把a的值送给outfile 当没有1.txt文件的时候，会创建这个文件，并输出 同时outfile的类型为bool型，可以判断文件是否成功打开 if(!outfile) //如果文件没有成功打开，则为false 文件的输入 ifstream infile("2.txt")int a;infile &gt;&gt; a; //将infile的值送给awhile(infile &gt;&gt;a) 同时 cin&gt;&gt;的终止符为空格、tab、回车 &nbsp;]]></content>
      <categories>
        <category>essential c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[try]]></title>
    <url>%2F2019%2F07%2F13%2Ftry%2F</url>
    <content type="text"><![CDATA[first time]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>表格</tag>
        <tag>表单验证</tag>
      </tags>
  </entry>
</search>
