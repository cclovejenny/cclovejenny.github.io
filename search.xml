<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[essential第三章]]></title>
    <url>%2F2019%2F07%2F14%2F%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[1.指针的运算 可以对指针使用下标运算符 下标运算符就相当于在起始地址的基础上加上索引值，产生某个元素的地址 #include&lt;iostream&gt;using namespace std;int main(){ int a[]={1,2,3,4,5}; int *p=a; cout &lt;&lt; p[1];//或者cout &lt;&lt; *(p+1); cout&lt;&lt; *p[1]是错误的} 上面程序的输出为2， 所以 p[1] = *(p+1) 对于书中的对vector和array的泛型算法： template &lt;typename elemtype&gt;elemtype* find(const elemtype *array,int size,const elemtype &amp;value){ // array就是数组的首地址 if(!array || size&lt;1){ return 0; } for(int i=0;i&lt;size;i++){ if(array[i]==value) return &amp;array[i]; //可以看出array[i]是一个具体的值。而不是对象，就相当于数组一样 } return 0;} 除了使用指针的下标计算外，还可以： template &lt;typename elemtype&gt;elemtype* find(const elemtype *array,int size,const elemtype &amp;value){ if(!array || size&lt;1){ return 0; } for(int i=0;i&lt;size;i++,++array){ //由此 for语句不仅仅是每个部分一句，可以多句 if(*array==value) //由地址提领到他的值 return array; //返回当前地址 } return 0;} 2.iterator 需要实现的功能 for(iter=vec.begin();iter !=vec.end();++iter){ cout &lt;&lt; *iter &lt;&lt; endl;} vector&lt;int&gt; vec;vector&lt;int&gt; ::iterator iter=vec.begin() 可以通过iter调用vector的函数 iter-&gt;size() 3.容器公用的操作 4.使用顺序性容器 定义容器的方式 // 产生空的容器vector&lt;int&gt; vec;list&lt;string&gt; ilist; //产生特定大小的容器，每个元素为默认值，int double默认值为0list&lt;int&gt; ilist(1024);vector&lt;string&gt; ivec(32); //产生特定大小的容器，并为每个元素赋初值vector&lt;int&gt; ivec(10,-1)list&lt;string&gt; slist(16,"abcdefg") //通过对iterator产生容器int ia[8]={1,2,3,4,5,6,7,8}vector&lt;int&gt; fib(ia,ia+8) //通过一个容器，产生另外一个容器list&lt;string&gt; slist;list&lt;string&gt; slist2(slist) 容器的插入和删除的操作 push_back()//末尾插入pop_back()//末尾删除 5.使用泛型算法 6.设计泛型算法 设计一个程序，给与一个vector，现在返回一个vector，内含原vector中所有小于10的元素 vector&lt;int&gt;less_than_10(const vector&lt;int&gt; &amp;vec){ vector&lt;int&gt; nvec; for (int i = 0; i &lt; vec.size(); ++i) { if(vec[i]&lt;10) nvec.push_back(vec[i]); } return nvec;} 现在要去改进程序，可以指定边界数，同时可以指定大于、小于、等于 vector&lt;int&gt; filter(const vector&lt;int&gt; &amp;vec,int value,bool (*pred)(int,int)){ vector&lt;int&gt; nvec; for(int i=0;i&lt;vec.size();i++){ if(pred(vec[i],value)) nvec.push_back(vec[i]); } return nvec;} bool less_than(int a,int b){ return a&lt;b ? true:false;} bool more_than(int a,int b){return a&gt;b ? true:false;} 这里使用函数指针，通过函数指针可以达到指定大于小于的作用，记住，函数名和数组名一样，本质上就是指针，是一个地址。 实际的完整程序 #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt;less_than_10(const vector&lt;int&gt; &amp;vec){ vector&lt;int&gt; nvec; for (int i = 0; i &lt; vec.size(); ++i) { if(vec[i]&lt;10) nvec.push_back(vec[i]); } return nvec;} //使用函数指针 vector&lt;int&gt; filter(const vector&lt;int&gt; &amp;vec,int value,bool (*pred)(int,int)){ vector&lt;int&gt; nvec; for(int i=0;i&lt;vec.size();i++){ if(pred(vec[i],value)) nvec.push_back(vec[i]); } return nvec;} bool less_than(int a,int b){ return a&lt;b ? true:false;} bool more_than(int a,int b){return a&gt;b ? true:false;} //vector&lt;int&gt; avec=filter(big_vec,value,less_than)int main(){ int a[6]; for(int i=0;i&lt;6;i++){ int b; cin &gt;&gt; b; a[i]=b; } vector&lt;int&gt;vec(a,a+6); vector&lt;int&gt; svec=filter(vec,5,less_than); for(int i=0;i&lt;svec.size();i++){ cout &lt;&lt; svec[i] &lt;&lt; endl; }} function object //头文件#include&lt;functional&gt; 可以实现： sort(vec.begin(),vec.end()，greater&lt;int&gt;) 通过greater，可以使得排列之后的容器是从大到小 常用的有： 算术运算符：plus&lt;type&gt;、minus&lt;type&gt;、negate&lt;type&gt;、multiplies&lt;type&gt;、divides&lt;type&gt;关系运算符：less&lt;type&gt;、less_equal&lt;type&gt;、greater&lt;type&gt;、greater_equal&lt;type&gt;、 equal&lt;type&gt;、not_equal_to&lt;type&gt;逻辑运算符：logical_and&lt;type&gt;、logical_or&lt;type&gt;、logical_not&lt;type&gt; function object adapter 例如上面的less&lt;type&gt;，是希望外界传入两个值，如果符合要求，就返回true，而我们设置的filter函数事希望传入的一个值一直和设定的值比较，所以需要使用adapter，将less&lt;type&gt;转化为一元运算符。 使用bind1st将值绑定到第一操作数，bind2nd将值绑定到第二操作数。 vector&lt;int&gt; filter(const vector&lt;int&gt; &amp;vec,int value,less&lt;int&gt; &amp;lt){ vector&lt;int&gt; nvec; vector&lt;int&gt; ::iterator iter=nvec.begin(); while((iter=find_if(iter,nvec.end(),bind2nd(lt,value)))!=nvec.end()){ nvec.push_back(*iter); iter++; } return nvec;}]]></content>
      <categories>
        <category>essential c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建]]></title>
    <url>%2F2019%2F07%2F13%2Fhexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1.hexo首页不显示全文 希望达到的效果 首页显示文章列表，列表里的每一篇文章只显示预览，不显示全文。 进入hexo博客项目的themes/next目录 用文本编辑器打开_config.yml文件 搜索"auto_excerpt",找到如下部分： # Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 把enable改为对应的false改为true，然后hexo d -g，再进主页，问题就解决了！ 2.添加Live2D小宠物 安装Live2D插件 npm install --save hexo-helper-live2d npm install --save live2d-widget-model-&lt;你喜欢的模型名字&gt; &nbsp;下面是常用的模型 可以在此预览 live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 修改配置文件 在博客根目录的_config.yml配置文件中添加下面的内容 #Live2D动画live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-shizuku display: position: right width: 150 height: 300 mobile: show: true 主要参数说明 enable //是否使用 model: use: live2d-widget-model-shizuku //要使用的模型名称 display: position: right //显示的位置 width: 150&nbsp;&nbsp; &nbsp;//宽度 height: 150&nbsp;&nbsp; &nbsp;//高度 mobile: show: true&nbsp;&nbsp; &nbsp;//移动端是否显示 &nbsp; 3.添加分类以及标签 nexT主题的文章分类和标签设置，其他主题也应该是类似的。添加成功后会在侧边栏或导航栏生成“分类”和“标签”这两个选项 &nbsp; 见如下博客以及这篇]]></content>
      <categories>
        <category>环境搭建</category>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[conda常用命令整理]]></title>
    <url>%2F2019%2F07%2F13%2Fconda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[安装anaconda发行版中所有的包 conda install anaconda 查看当前虚拟环境cuda cudnn版本 &nbsp;conda list 并查看 cat /usr/local/cuda-9.0/version.txtcat /usr/local/cuda-9.0/include/cudnn.h | grep CUDNN_MAJOR -A 2 更换清华源 不同的安装包存在的位置可能不一样，例如cuda不同版本的安装包分别在free和main里面 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ &nbsp; 安装指定版本的tensorflow conda install --channel https://conda.anaconda.org/anaconda tensorflow-gpu=1.5.0 或者 pip3 install tensorflow-gpu==1.5 -i https://pypi.tuna.tsinghua.edu.cn/simple 移除虚拟环境 conda env remove -n python35 安装opencv conda install --channel https://conda.anaconda.org/menpo opencv3 pip使用国内源 加上 -i https://pypi.tuna.tsinghua.edu.cn/simple 例如安装 例如： pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider 这样就会从清华这边的镜像去安装pyspider库。 安装8.0版本的cuda&nbsp; 安装固定版本的cuda cudnn conda install cudatoolkit=8.0 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/linux-64/ conda install cudnn=7.0.5 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/ &nbsp; &nbsp;9.0版本以上的cuda&nbsp; &nbsp;可以查看清华源中有没有cuda的对应版本 conda install cudatoolkit=9.0 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/ conda install cudnn=7.1.2 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/ pytorch torchvision指定版本 conda install pytorch=0.3.0 torchvision=0.2.0 -c soumith &nbsp;]]></content>
      <categories>
        <category>环境搭建</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>环境搭建 深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[essential第二章]]></title>
    <url>%2F2019%2F07%2F13%2Fessential%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[1.编写函数 返回类型 函数名 参数列表 必须先声明，定义可以延后 返回值 必须在每个可能的退出点上将值返回，函数体的最后一句不是return，则这一句就是函数的隐式退出点 2.调用函数 传值 传值时，传入的值和原来的值得唯一的联系，就是值相同，相当于复制了一份，在我们调用函数的时候，会在内存中建立一个特殊区域，程序堆栈，为每个函数的参数提供存储空间，一旦函数完成，内存就会释放。这些对象为局部对象。 传址 传址的方式传入函数的是对象的地址，而不是复制的一份，采用引用的方式传入。 void display(const vector&lt;int&gt; &amp;vec){ for(int i=0;i&lt;vec.size();i++){ cout &lt;&lt; vec[i] &lt;&lt; " "; cout &lt;&lt; endl; }} 作用域和范围 函数内定义的对象，只存在于函数执行的期间，如果把这些局部对象的地址返回，会出错。 int* display(const vector&lt;int&gt; &amp;vec){ int a; a=3; return &amp;a;} 3.默认参数值 void display(const vector&lt;int&gt; &amp;vec,ostream &amp;os=cout){ for(int i=0;i&lt;vec.size();i++){ os &lt;&lt; vec[i] &lt;&lt; endl; }} 定义一个ostream的对象，将其的初值赋值为cout，这样默认的是打印在屏幕上，也可以选择输出到文件中。 4.局部静态对象 const vector&lt;int&gt; *seq(int size){ static vector&lt;int&gt; elems; return &amp;elems;} 此时函数可以返回静态局部变量的地址，因为在函数执行结束的时候，elem并不会从内存中消失，依然存在，其存在的范围是当前的文件中。 5.inline函数 inline函数的作用，就是声明当前的函数，要求编译器在每个函数的调用点上，将函数展开。 6.重载函数 不能根据返回值的类型来重载函数，而是参数列表中，参数类型以及参数数量的不同 7.模板函数 template &lt;typename elemtype&gt;void display_message(const string &amp;msg,const vector&lt;elemtype&gt; &amp;vec){ cout &lt;&lt; msg; for(int i=0;i&lt;vec.size();i++){ elemtype t=vec[i]; cout &lt;&lt; t &lt;&lt; ' '; }} 其实就是定义一个类型，函数不指定类型的输入，elemtype是一个暂时存放类型的占位符。 8.函数指针 首先要注意 int *f(int i, int j); int (*p)(int i, int j); 第一个是返回指针的函数，第二个是指向函数的函数指针， 函数名和数组类似，也是代表函数所存放的地址，函数名就代表了函数的地址。 函数指针的定义 将函数名换成指针，同时制定参数列表。 double add(double x, double y){&nbsp;&nbsp; &nbsp;return x + y;} //函数指针double (*pf)（double,double）=add; &nbsp;//这里(*pf)的括号不能省，不然就不是函数指针了。 函数指针的数组 double add(double x, double y){ return x + y;} double add2(double x, double y){ return x - y;}double (*pf[2])(double,double) = { add, add2 }; pf是有2个函数指针的数组 应用 对于第一种， #include&lt;iostream&gt;using namespace std;double add(double x, double y){ return x + y;} double calculate(double x1, double y1, double(*f)(double, double)) //函数调用里面传递 函数指针数组 的方法{ cout &lt;&lt; "add:" &lt;&lt; (*f)(x1, y1) &lt;&lt; endl; return 1;} int main(){ double (*pf)(double,double)=add; //这里(*pf)的括号不能省，不然就不是函数指针了。 int x = 2,y = 1; calculate(x, y, pf); //直接calculate(x, y, add);也是可以的 } 第二种： #include "iostream"&nbsp;using namespace std;&nbsp;double add(double, double);double add2(double x, double y);&nbsp;double calculate(double x1, double y1, double(*f[])(double, double)) &nbsp;//函数调用里面传递 函数指针数组 的方法 {&nbsp;&nbsp; &nbsp;cout &lt;&lt; "add:" &lt;&lt; (*f[0])(x1, y1) &lt;&lt; endl;&nbsp;&nbsp; &nbsp;cout &lt;&lt; "add2:" &lt;&lt; (*f[1])(x1, y1) &lt;&lt; endl;&nbsp;&nbsp; &nbsp;return &nbsp;1;}&nbsp;int main(){&nbsp;&nbsp; &nbsp;int x, y;&nbsp;&nbsp; &nbsp;double (*pf[2])(double,double) = { add, add2 };&nbsp;//&nbsp;&nbsp; &nbsp;x = 2; y = 1;&nbsp;&nbsp; &nbsp;calculate(x, y, pf); //注意此处的pf，他是函数的名字，就是指针，而这个指针指向的还是指针，即add这个函数名（函数名也是指针），所以在calculate函数的定义中，要用(*f[])或者(**f)&nbsp;&nbsp;&nbsp; &nbsp;system("pause()");&nbsp;&nbsp; &nbsp;return 0;}&nbsp;&nbsp;&nbsp;double add(double x, double y){&nbsp;&nbsp; &nbsp;return x + y;}&nbsp;double add2(double x, double y){&nbsp;&nbsp; &nbsp;return x - y;} 然后建立函数数组并赋值 &nbsp;double (*pf[2])(double,double) = { add, add2 };&nbsp; 接着传递给上面定义的calculate函数。调用方式为：calculate(x, y, pf); calculate函数的接收方式应为：double calculate(double x1, double y1, double(**f)(double, double)) //传递的pf是一个数组的数组名且本身也是一个指针，即为二重指针 &nbsp;&nbsp;&nbsp;&nbsp;或者double calculate(double x1, double y1, double(*f[])(double, double)) 9.头文件 将函数的声明放在头文件中，方便多个程序调用&nbsp;]]></content>
      <categories>
        <category>essential c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[essential第一章整理]]></title>
    <url>%2F2019%2F07%2F13%2Fessential%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[1.array和vector 定义array，必须指定array的元素类型，名称，指定尺度的大小，并且这个大小必须是常量表达式 vector本身的大小就是可变的，因此不一定要指定大小的时候为常量表达式 //arrayconst int seq_size=18; //定义一个常量表达式int pell_seq[seq_size]; //vectorint a=10; //变量vector&lt;int&gt; b(a); 同时还可以让计算机自行计算array的大小 int elem_seq[]={1,2,3,4,5,6,7,8,9}; 2.指针 指针调用成员函数： vector&lt;int&gt; fib;vector&lt;int&gt; *pv=0;pv=&amp;fib; //成员函数的调用方式 fib.empty()pv-&gt;empty() 3.文件的读写 文件的输出 #include&lt;fstream&gt;ofstream outfile("1.txt"); //定义了一个ofstream类的outfile的对象//没有ofstream outfile ="1.txt"的写法int a=3;outfile &lt;&lt; a; //相当于把a的值送给outfile 当没有1.txt文件的时候，会创建这个文件，并输出 同时outfile的类型为bool型，可以判断文件是否成功打开 if(!outfile) //如果文件没有成功打开，则为false 文件的输入 ifstream infile("2.txt")int a;infile &gt;&gt; a; //将infile的值送给awhile(infile &gt;&gt;a) 同时 cin&gt;&gt;的终止符为空格、tab、回车 &nbsp;]]></content>
      <categories>
        <category>essential c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[try]]></title>
    <url>%2F2019%2F07%2F13%2Ftry%2F</url>
    <content type="text"><![CDATA[first time]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>表格</tag>
        <tag>表单验证</tag>
      </tags>
  </entry>
</search>
